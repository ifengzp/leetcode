{"./":{"url":"./","title":"Introduction","keywords":"","body":"数据结构与算法 学习参考网站 数据结构和算法动态可视化 刷题记录 第一周 （2020.02.02 ~ 2020.02.08） 简单-两数之和-字典查找 中等-最长回文子串-动态规划 简单-整数反转-数字溢出 简单-反转单向链表-链表 powered by Gitbook该文件修订时间： 2020-02-08 13:00:38 "},"basic_concept/time_complexity.html":{"url":"basic_concept/time_complexity.html","title":"时间复杂度","keywords":"","body":"时间复杂度 概念 时间频度：一般来说哪个语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 常见的算法时间复杂度如下图所示：常数阶O(1)，对数阶O(log₂n)，线性阶O(n)，线性对数阶O(nlog₂n)，平方阶O(n²)，立方阶O(n³)，k次方阶O(nᵏ)，指数阶O(2ⁿ) 求解算法时间复杂度的具体步骤 找出算法中的基本语句 计算基本语句的执行次数的数量级 用大O记号表示算法的时间性能 常数阶O(1)和线性阶O(n) let temp=1, i=2, j=3; temp=i; // ① 该语句的频度为 1 i=j; // ② 该语句的频度为 1 j=temp; // ③ 该语句的频度为 1 因为f(n) = 1+1+1，所以它的时间复杂度为O(1) let a=0; // ① 该语句的频度为 1 let b=1; // ① 该语句的频度为 1 for (i=1; i 因为f(n)=1+1+n+3(n-1)=4n-1，所以它的时间复杂度为O(n) 📌上面两个的区别是：第一段代码不和规模n有关，当算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数，所以此类算法的时间复杂度是O(1)；一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1) 平方阶O(n²) let sum=0; // ① 该语句的频度为 1 for(i=1; i 因为f(n)=1+n+n²+n²=2n²+n+1，所以它的时间复杂度为 O(n²) for (i=1; i 因为f(n)=2n²-n-1+n-1=2n²-1，所以它的时间复杂度为 O(n²) for (i=0; i 因为内循环体的f(n)=0+1+2+3+4+...+(n-1)=(n-1)n/2=n²/2-n/2，所以它的时间复杂度为 O(n²) O(log₂n) i=1; // ① 该语句的频度为 1 while (i fn取最大值，即f(n)=1+log₂n，所以它的时间复杂度为 O(log₂n) O(n³) for(i=0; i 因为f(n)=n+n²+n³，所以它的时间复杂度为 O(n³) 参考文章 算法的时间复杂度和空间复杂度-总结 大O作弊表 powered by Gitbook该文件修订时间： 2020-02-08 13:00:38 "},"basic_concept/js数据结构描述.html":{"url":"basic_concept/js数据结构描述.html","title":"js数据结构描述","keywords":"","body":"使用js实现常见的数据结构：数组，列表，栈，队列，链表，字典，散列，集合，二叉树和二叉查找树，图 列表 列表。列表是一组有序的数据，每个列表中的数据项称为元素。列表的抽象数据类型定义： 方法 定义 length 返回列表的元素个数 append 在列表的末尾添加新元素 find 在列表中查找元素 remove 从列表中删除元素 clear 清空列表中的所有元素 toString 返回列表的字符串形式 insert 在现有元素后面插入新元素 currPos 返回列表的当前位置 front 将列表的当前位置移动到第一个元素 end 将列表的当前位置移动到最后一个元素 prev 将列表的当前位置前移一位 next 将列表的当前位置后移一位 hasPrev 判断是否有前一位 hasNext 判断是否有后一位 moveTo 将当前位置移动到指定位置 class List { constructor() { this._dataStore = []; this._listSize = 0; this._pos = 0; } length() { return this._listSize; } append(el) { this._dataStore[this._listSize++] = el; } find(el) { return this._dataStore.findIndex(item => item == el); } remove(el) { const foundAt = this.find(el); if (foundAt > -1) { this._dataStore.splice(foundAt, 1); --this._listSize; } } clear() { this._dataStore = []; this._pos = this._listSize = 0; } toString() { return this._dataStore.join(); } insert(el, after) { const foundAt = this.find(after); if (foundAt 0; } prev() { if(this.hasPrev()) --this._pos; return this.currPos(); } next() { if(this.hasNext()) ++this._pos; return this.currPos(); } moveTo(pos) { if (0 栈 栈。栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一段称为栈顶。栈被称为一种后入先出的数据结构。 方法 定义 length 返回栈内元素个数 push 元素入栈 pop 元素出栈 peek 返回栈顶元素 empty 返回栈内是否为空 clear 清空栈内元素 class Stack { constructor() { this._dataStroe = []; this._top = 0; } length() { return this._top; } push(el) { this._dataStroe[this._top++] = el; } pop() { --this._top; return this._dataStroe.pop(); } peek() { return this._dataStroe[this._top - 1]; } clear() { this._dataStroe = []; this._top = 0; } } 队列 队列。队列是一种列表，不同的是队列只能在队尾插入元素，在对首删除元素，队列用于存储按顺序排列的数据，先进先出。在列表的实际使用中有时还会遇到需要插队的情况，这种数据结构叫做优先队列，出队伍的时候优先权最高的元素先出。 方法 定义 length 返回队列元素的个数 toString 显示队列内所有元素 enqueue 入队 dequeue 出队 front 读取对首元素 end 读取对尾元素 empty 判断队伍是否为空 class Queue { constructor() { this._dataStore = []; } length() { return this._dataStore.length; } toString() { return this._dataStore.join(); } enqueue(el) { this._dataStore.push(el); } dequeue() { return this._dataStore.shift(); } front() { return this._dataStore[0]; } end() { return this._dataStore[this._dataStore.length - 1]; } empty() { return !this._dataStore.length; } toString() { return this._dataStore.join(); } } 链表 链表。链表是由一组节点组成，每个节点都使用一个对象的引用指向它的后继，指向另一个节点的引用叫做链。需要拿链表和数组做一个对比，在很多编程语言中数组有很大的局限，数组被实现成的长度是固定的，这样当数组被填满后再舔新元素会很麻烦，而且操作数组也不像js一样有能直接使用的api。在js中数组的最大问题是被实现成了对象，相对其他编程语言，js的数组效率更低。当你觉得js中的数组在实际中使用很慢的时候，就可以考虑使用链表，除了对数据的随机访问，链表几乎可以使用在任何可以使用一维数组的情况中。 方法 定义 head 头节点 find 寻找节点 findPrev 寻找上一个节点 insert 插入节点 remove 删除节点 display 显示链表中的元素 function Node(el) { this.element = el; this.next = null; } class LList { constructor() { this._head = new Node('head'); } find(item) { let currentNode = this._head; while(currentNode.element != item) { currentNode = currentNode.next; } return currentNode; } insert(newEl, item) { const newNode = new Node(newEl); const currentNode = this.find(item); newNode.next = currentNode.next; currentNode.next = newNode; } findPrev(item) { let currentNode = this._head; while(!(currentNode.next == null) && (currentNode.next.element != item)) { currentNode = currentNode.next; } return currentNode; } remove(item) { const prevNode = this.findPrev(item); if (!(prevNode.next == null)) { prevNode.next = prevNode.next.next; } } display() { let currentNode = this._head; const arr = []; arr.push(currentNode.element); while(currentNode.next != null) { currentNode = currentNode.next; arr.push(currentNode.element); } return arr; } } 字典 字典。字典是一种以键-值对形式存储数据的数据结构 方法 定义 add 增加字典中的元素 find 寻找字典中的元素 remove 移除字典中的元素 showAll 展示字典中的所有元素 class Dictionary { constructor() { this._dataStore = []; } add(key, value) { this._dataStore[key] = value; } find(key) { return this._dataStore[key]; } remove(key) { delete this._dataStore[key]; } showAll() { return this._dataStore; } } 散列表 散列。散列是一种常用的数据存储技术，散列后的数据可以快速地插入或者使用。散列使用的数据结构叫做散列表。在js中用数组来实现散列表，数组的长度是预先设定的，理想状况下散列函数会将每个键值映射成一个唯一的数组索引，并且将键均匀地映射到数组中。但是即便散列函数很高效，还是会存在将两个键值映射成同一个值得可能，这种现象叫做碰撞。实现一个散列表首先要确定的是数组的长度和散列函数。 集合 集合是一种包含不同元素的数据结构。集合中的元素称为成员，集合中两个最重要的特性是： 首先，集合中的成员是无序的；其次，集合中不允许相同的成员存在。js中可以通过Set对象实现集合 二叉查找树 树。树是一种非线性的数据结构，以分层形式存储数据，数被用来存储具有层级关系的数据。一棵树中最上面的节点称为根节点，如果一个节点下面连接多个节点，那么这个节点称为父节点，它下面的节点叫做子节点，没有任何子节点的节点称为叶子节点。树的层数叫做数的深度，从一个节点到另一个节点的一组边叫做路径，以某种方式访问树中所有的节点叫做树的遍历。二叉树是一种特殊的树，它的子节点树不超过两个，二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。 方法 定义 insert 给二叉查找树增加节点 find 寻找节点 inOrder 给返回排序后的节点 insert 插入节点 getMin 获取最小节点 getMax 获取最大节点 function Node (data, left, right) { this.data = data; this.left = left; this.right = right; this.show = () => this.data; } class BST { constructor() { this._root = null; } insert(data) { const n = new Node(data, null, null); if (this._root == null) { this._root = n; } else { let current = this._root; let parent; while(true) { parent = current; if (data 图 图。图是由边的集合及顶点的集合组成。顶点有权重也称为成本，边由顶点对定义，如果边有方向，图就叫有向图，反之叫做无向图。图中一系列的顶点构成路径，路径中所有的顶点都由边连接。路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示。由指向自身的顶点组成的路径称为环，环的长度为0。圈是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同。只要是没有重复边或重复顶点的圈，就是一个简单圈，反之称为平凡圈。如果两个顶点之间有连接，那么这两个顶点就是强连通的。 powered by Gitbook该文件修订时间： 2020-02-08 13:00:38 "},"work_accumulation/最佳配对率-动态规划.html":{"url":"work_accumulation/最佳配对率-动态规划.html","title":"最佳配对率-动态规划","keywords":"","body":"最佳匹配率 题目来源 题目来源于项目中的一个”基因“配对小游戏，如下： 给出一个长度为10的由基因“ATGC”随机组成的参照字符串，然后再给出一个长度为6的可操作基因字符串，可操作字符串的字符顺序不能变，但是可以移动其位置，求移动字符串和参照字符串的最大配对率 参考碱基序列为：GGACCCATTC 可顺序移动碱基序列为：TACAGT**** 其中*可移动，匹配率 = 符合配对规则的字母个数 / 总字母个数 当可移动碱基的位置为*TAC**AGT*时有和参考序列有4个碱基匹配，此时匹配率为：4/10，是最优匹配率 解题思路 方法一： 全组合 为了节省时间，项目中采取了全组合的方法，把所有情况列举出来，然后对比，取匹配率最高的一种情况作为答案。 转换一下就知道，题目等于是有10个位置，任意取四个放空白碱基，一共有C(10,4) = 10!/(4! * 6!) = 10 * 9 * 8 * 7 / (1 * 2 * 3 * 4) = 210种情况，代码如下： function toCalculateBestPairingRatio() { const contrastGene = 'GGACCCATTC'.split(''); const gene = 'TACAGT'.split(''); let tempGene, curNum = 0; let bestPairingRate = { rate: 0, arrangement: '' }; for (let i = 0; i acc + (cur === tempGene[index]), 0); if (curNum >= bestPairingRate.rate) { bestPairingRate.rate = curNum; bestPairingRate.arrangement = tempGene; } } } } } return bestPairingRate; } 方法二 动态规划 全组合虽然能够解决本次问题，但是其复杂度为Ο(n⁴)，当基数再大一点的时候就不适合了。像这种求解最优的问题非常适合使用动态规划，把上题中的基因通过表格列出，行表示参考碱基序列，列表示可顺序移动碱基序列，从第一个碱基开始逐渐增加，表格内为最佳碱基配对率 j\\i G G A C C C A T T C T 0 0 0 0 0 0 0 1 1 1 A - 0 1 1 1 1 1 1 1 1 C - - 0 2 2 2 2 2 2 2 A - - - 0 2 2 3 3 3 3 G - - - - 0 2 2 3 3 3 T - - - - - 0 2 3 4 4 Row表示行，i为其下标，Col表示列，j为其下标，Rate表示最佳匹配率，通过观察可以找出其状态转移方程为： Rate[j][i] = Max{Rate[j-1][i-1] + Number(Row[i] == Col[j]), Rate[j][i - 1]} 其中当只有一行时Rate[j-1][i-1] = 0，表格左下角则为最大的匹配率 function toCalculateBestPairingRatio() { const contrastGene = 'GGACCCATTC'.split(''); const gene = 'TACAGT'.split(''); let arr = [] for (let j = 0; j 该方法的算法复杂度为平方阶，能够完美解决当前问题，就算后面的基数扩增也不怕了 powered by Gitbook该文件修订时间： 2020-02-08 13:00:39 "},"question_bank/简单-两数之和-字典查找.html":{"url":"question_bank/简单-两数之和-字典查找.html","title":"简单-两数之和-字典查找","keywords":"","body":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解题思路 方法一 O(n²)：数组循环 首先想到的方法就是通过循环暴力破解，twoSum_1的内层循环次数是n²，复杂度为O(n²) function twoSum_1(nums, target) { if (nums.length 方法二 O(n²)：数组循环，降低内层循环次数 修改后的twoSum_2虽然复杂度还是O(n²)，但是它的内层循环次数是(n-1)n/2，性能更优 function twoSum_2(nums, target) { if (nums.length 方法三 O(n)：字典查找 数组遍历查找和字典查找的时间复杂度是不一样的，for循环的复杂度是O(n)，而字典查找的复杂度是O(1)，因此把数据结构从数组改为Set之后可以把时间复杂度降低一个维度。同样twoSum_4和twoSum_3虽然复杂度都是O(n)，但是twoSum_4的循环次数更少，解法更优 function twoSum_3(nums, target) { let set = new Set(); for (let i = 0; i 最优解法 当把测试数组的长度设置为10000之后，在我本地环境下分别测得上述四个函数的用时为2827.761ms、1005.871ms、8.863ms、3.739ms，twoSum_4解法最优 字典查找的复杂度为O(n)，数组遍历查找的复杂度为O(1)，字典查找更优 同等复杂度的解法下还可以优化循环次数 powered by Gitbook该文件修订时间： 2020-02-08 13:00:39 "},"question_bank/中等-最长回文子串-动态规划.html":{"url":"question_bank/中等-最长回文子串-动态规划.html","title":"中等-最长回文子串-动态规划","keywords":"","body":"最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 测试用例一 输入: \"babad\" 输出: \"bab\" （\"aba\" 也是一个有效答案） 测试用例二 输入: \"cbbd\" 输出: \"bb\" 解题思路 方法一O(n³): 暴力遍历 第N个符合条件的字符串，等于前N-1个字符串加上第N个字符然后取反，那么这个字符串就是回文字符串。它只能找出从头开始的字符，所以还得在外层添加一个循环，更改字符串的起点。以下就是该解法写出来的函数，递归部分复杂度是O(n²)，然后外层再套一个N层的遍历，所以它的复杂度是O(n³)。 function longestPalindrome(str) { let idx = 0; let startIdx = 0; let len = str.length; let maxSubStr = str[0]; let curStr = ''; if (len = maxSubStr.length) { maxSubStr = curStr; } loop() } } loop() startIdx+=1; } return maxSubStr } 但是在LeetCode上提交的时候，第41个用例超时了。该用例的长度为877，我本地在不限时间地跑该用例的耗时是3569.156ms，最长回文子串为fklkf；总结一下问题主要是由于递归解法的效率比较低，函数重复嵌套调用，而且并没有提炼出相同的子问题 ibvjkmpyzsifuxcabqqpahjdeuzaybqsrsmbfplxycsafogotliyvhxjtkrbzqxlyfwujzhkdafhebvsdhkkdbhlhmaoxmbkqiwiusngkbdhlvxdyvnjrzvxmukvdfobzlmvnbnilnsyrgoygfdzjlymhprcpxsnxpcafctikxxybcusgjwmfklkffehbvlhvxfiddznwumxosomfbgxoruoqrhezgsgidgcfzbtdftjxeahriirqgxbhicoxavquhbkaomrroghdnfkknyigsluqebaqrtcwgmlnvmxoagisdmsokeznjsnwpxygjjptvyjjkbmkxvlivinmpnpxgmmorkasebngirckqcawgevljplkkgextudqaodwqmfljljhrujoerycoojwwgtklypicgkyaboqjfivbeqdlonxeidgxsyzugkntoevwfuxovazcyayvwbcqswzhytlmtmrtwpikgacnpkbwgfmpavzyjoxughwhvlsxsgttbcyrlkaarngeoaldsdtjncivhcfsaohmdhgbwkuemcembmlwbwquxfaiukoqvzmgoeppieztdacvwngbkcxknbytvztodbfnjhbtwpjlzuajnlzfmmujhcggpdcwdquutdiubgcvnxvgspmfumeqrofewynizvynavjzkbpkuxxvkjujectdyfwygnfsukvzflcuxxzvxzravzznpxttduajhbsyiywpqunnarabcroljwcbdydagachbobkcvudkoddldaucwruobfylfhyvjuynjrosxczgjwudpxaqwnboxgxybnngxxhibesiaxkicinikzzmonftqkcudlzfzutplbycejmkpxcygsafzkgudy 方法二O(n²)：动态规划/中心扩展 方法一执行超时之后换种指导思想，往动态规划方向想，想到的第一个状态转移方程是F(n+1) == str[n-1]+F(n)+str[n+1] 且满足 str[n+1] == str[n-1]。它刚好可以用递推来实现，因为每个单独的字母都是一个符合条件的答案，然后往左右递增扩展，如果左右相同，那就能够得出下一个回文，直到找到最长的回文。但是这样解的话还要区分两种情况，如果回文的长度是基数，比如cabad的输出是aba，它的中心位是一个字母，但是如果回文的长度是偶数，比如abbc的输出是bb，那它的中心位就是两个字母，所以使用这个方法得分别对这两种情况做处理，下面的代码就是基于这种解法而来，官方解法更简洁 function longestPalindrome(str) { if (str.length str2.length ? str1 : str2; maxStr = result.length > maxStr.length ? result : maxStr; } return maxStr; } function search(str, curIdx, isEven) { let prevIdx, nextIdx; let result = str[curIdx]; if (isEven) { if (str[curIdx] == str[curIdx + 1]) { result += str[curIdx + 1]; } else { return result; } } let maxLoopTime = Math.min(str.length - curIdx, curIdx); for (let n = 1; n 方法二可以改良，上面的逻辑针对回文中心是一个字母的和两个字母两种情况分别做了处理，如果取巧一点，往字符串前后，以及每个字母之间插入一个#，就能够把回文中心是两个字母的情况给去掉，比如cabad插入后变成#c#a#b#a#d#，它的输出是#a#b#a#，回文中心还是字母；abbc插入后变成#a#b#b#c#，它的输出是#b#b#，回文中心变成了#也是一个字母，在这个基础上使用中心扩展就不用考虑两种情况了，这其实也是马拉车算法的第一步。 powered by Gitbook该文件修订时间： 2020-02-08 13:00:39 "},"question_bank/简单-整数反转-数字溢出.html":{"url":"question_bank/简单-整数反转-数字溢出.html","title":"简单-整数反转-数字溢出","keywords":"","body":"整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2³¹, 2³¹ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 输入123，输出321 输入120，输出21 输入-123，输出-321 解题思路 方法一，字符串转数组，reverse后再转数字 很快就会想到取整，然后利用数组反转，然后加上符号位得到反转后的数字，然后判断是否溢出，如果溢出就返回0，然后写出了下面的代码，而且也通过了LeetCode的测试 function reverse(x) { let result = String(Math.abs(x)).split('').reverse().join(''); result = x Math.pow(2,31) - 1 || result 虽然它通过了测试，但是这样实现是有问题的，因为在一个只能存储得下32位的有符号整数的环境中，如果整数反转后的数值超过要求的数值范围，也就是这一步result = x ，我们根本得不到 result，它会直接溢出。 这里的话看语言的实现对溢出的处理，其实有两种做法（这里并没有做实践） 如果溢出会报错的话，就try,catch包一下，捕获到报错就直接返回0； 如果溢出不报错，那可以把溢出后的值再反转一下和输入对比，如果不一样就说明溢出了，直接返回0，如果一样就说明没有溢出，输出result就可以了 方法二，利用数学方法，按位取余并复原 取反除了利用数组的方法外，还可以利用数学的方法，数学中对10取余可以拿到最后一位数字，对10取除则可以去掉最后一位数字，同时在此基础上对溢出进行判断就可以了 function reverse(x) { let MAX_VALUE = Math.pow(2,31) - 1; // 2147483647 let MIN_VALUE = -Math.pow(2,31); // -2147483648 let result = 0; while (x != 0) { pop = x % 10; x = parseInt(x / 10); if (result > parseInt(MAX_VALUE / 10) || (result == parseInt(MAX_VALUE / 10) && pop > 7)) return 0; if (result powered by Gitbook该文件修订时间： 2020-02-08 13:00:39 "},"question_bank/简单-反转单向链表-链表.html":{"url":"question_bank/简单-反转单向链表-链表.html","title":"简单-反转单向链表-链表","keywords":"","body":"反转链表 反转一个单链表 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 解题思路 解法一 利用数组或者栈的存储结构 在遍历的时候把节点存在数组里面，可以利用reverse方法，也可以利用数组存储特点做顺序记录 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ function reverseList(head) { if (!head) return head; let list = [],tempNode = null, curNode = head; while (curNode) { tempNode = curNode.next || null curNode.next = list[list.length - 1] || null list.push(curNode); curNode = tempNode } return list[list.length-1] }; 解法二 双指针 构建两个指针prev和cur分别存储上一个节点和当前节点，然后每次遍历的时候往后挪动两个指针，同时修改prev和cur的next指向 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ function reverseList(head) { let prev = null; let cur = head; let temp; while (cur) { temp = cur.next; cur.next = prev; prev = cur; cur = temp; } return prev; }; 解法三 递归 这道题使用递归的方法理解会比较绕，结合递归的执行栈 ① —-> ② —-> ③ —-> ④ —-> ⑤ —-> null 当前节点 返回节点 链表 ④ ⑤ ⑤ --> ④ --> null ③ ⑤ ⑤ --> ④ --> ③ --> null ② ⑤ ⑤ --> ④ --> ③ --> ② --> null ① ⑤ ⑤ --> ④ --> ③ --> ② --> ① --> null function reverseList(head) { if (!head || !head.next) return head; let nextLoopStartNode = reverseList(head.next); // 原本关系：headPrev = null, headNext = head.next // 反转操作：head.next = null, headNext.next = head head.next.next = head; head.next = null; return nextLoopStartNode; } powered by Gitbook该文件修订时间： 2020-02-08 13:00:39 "}}